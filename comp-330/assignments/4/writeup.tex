\documentclass[letterpaper,11pt]{article}

\author{Jacob Thomas Errington}
\date{5 November 2015}
\title{Assignment \#4\\Theory of Computing -- COMP 330}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{qtree}

\newtheorem{proposition}{Proposition}

\begin{document}

\maketitle

\begin{enumerate}
    \item Let $\#_x(s)$ represent the number of occurrences of the letter $x$
        in the string $s$.

        \begin{proposition}
            The given grammar generates the set of all strings $w \in \Sigma^*$
            such that $\#_a(w) = \#_b(w)$.
        \end{proposition}

        \begin{proof}
            Suppose we have a string having an equal number of occurrences of
            $a$s and $b$s. Of course, somewhere in this string, we will
            encounter the substring $ab$ or $ba$, which we will replace with an
            $S$, as this matches a rule in the grammar. Then, we may replace
            this $S$ with $\epsilon$, since that is a possible string generated
            by $S$. This procedure effectively reduces the length of the given
            string by $2$ on each iteration, and furthermore preserves the
            invariant that the string have equal occurrences of $a$ and $b$.
            Because the length is strictly decreasing, we arrive at the empty
            string, concluding that the string is recognized by the grammar.

            Now to show that the given grammar generates all strings of having
            equal occurrences of $a$ and $b$, we will use a form of induction.
            Of course, $\epsilon$ has equal occurrences of $a$ and $b$, and is
            a possible production of $S$. Now suppose $s$ and $s^\prime$ have
            equal occurrences of $a$ and $b$. Then, $asb$ and $bsa$ have equal
            occurrences of $a$ and $b$ since in each case, one of each letter
            is added. Also, $ss^\prime$ has equal occurrences of $a$ and $b$
            since $\#_a(s) + \#_a(s^\prime) = \#_a(ss^\prime)$ and
            $\#_b(s) + \#_b(s^\prime) = \#_b(ss^\prime$.
        \end{proof}

    \item
        To show that the language for simple C-style expressions is ambiguous,
        we will present a string having multiple valid parses.

        We will consider the string $a+++b$, and show that there is more than
        one possible parse for it, as seen in the parse trees in figures
        \ref{fig:postincrement} and \ref{fig:preincrement}.

        \begin{figure}
            \Tree
            [.S
                [.V
                    [.Post
                        [.I
                            $a$
                        ]
                        $+$
                        $+$
                    ]
                ]
                $+$
                [.V
                    [.I
                        $b$
                    ]
                ]
            ]

            \caption{
                A parse tree for the postincrement interpretation of $a+++b$.
            }
            \label{fig:postincrement}
        \end{figure}

        \begin{figure}
            \Tree
            [.S
                [.V
                    [.I
                        $a$
                    ]
                ]
                $+$
                [.V
                    [.Pre
                        [.I
                            $b$
                        ]
                        $+$
                        $+$
                    ]
                ]
            ]

            \caption{
                A parse tree for the preincrement interpretation of $a+++b$.
            }
            \label{fig:preincrement}
        \end{figure}

        Since the given grammar is not recursive, the unary incrementing
        operators cannot be nested; the only ambiguous string is
        $a+++b$. We can write unambiguous grammars for each interpretation by
        exhausting all the possible parses, of which there are only finitely
        many due to the lack of recursion, and then eliminating common
        subexpressions of rules by introducing new rules for them. We have used
        that procedure in the following two unambiguous grammars.

        First, here is a grammar that will parse $a+++b$ as including a
        post-increment.
        \begin{align*}
            S &\to (I | \langle Pre \rangle) + (I | P ) \\
            S &\to \langle Post \rangle + P \\
            P &\to \langle Pre \rangle | \langle Post \rangle
        \end{align*}

        Next, we will write a grammar to parse $a+++b$ as including a
        pre-increment.
        \begin{align*}
            S &\to I + ( I | \langle Post \rangle ) \\
            S &\to P + (I | P) \\
            P &\to \langle Pre \rangle | \langle Post \rangle
        \end{align*}

        The $I$, $\langle Pre \rangle$, and $\langle Post \rangle$ productions
        are exactly as in the original grammar.

\end{enumerate}

\end{document}
