\documentclass[11pt]{article}

\usepackage[geometry,questions]{jakemath}

\author{Jacob Thomas Errington}
\title{Assignment \#5\\Discrete structures 2 -- MATH 340}
\date{7 April 2017}

\begin{document}

\maketitle

\question{Combinatorial identities}

\begin{prop}
    We have
    %
    \begin{equation}
        \label{eq:identity}
        %
        \binom{n+1}{m+1} = \sum_{k=m}^n \binom{k}{m}
    \end{equation}
\end{prop}

\begin{proof}{(Algebraic.)}
    We proceed by induction on $n$.

    In the base case, we have $n = m$, so the sum degenerates into a single
    term in which the top and bottom of the binomial coefficient are the same.
    Similarly the left-hand side has equal top and bottom. Hence both evaluate
    to one.

    In the step case, suppose that
    %
    \begin{equation*}
        \binom{n+1}{m+1} = \sum_{k=m}^n \binom{k}{m}
    \end{equation*}
    %
    We want to show that
    %
    \begin{equation*}
        \binom{(n+1) + 1}{m+1} = \sum_{k=m}^{n+1} \binom{k}{m}
    \end{equation*}

    Starting from the right-hand side, we split the sum, use the induction
    hypothesis, and apply Pascal's identity.
    %
    \begin{equation*}
        \sum_{k=m}^{n+1} \binom{k}{m}
        =
        \binom{n+1}{m} + \sum_{k=m}^n \binom{k}{m}
        =
        \binom{n+1}{m} + \binom{n+1}{m+1}
        =
        \binom{(n+1)+1}{m+1}
    \end{equation*}
    %
    as required.
\end{proof}

\begin{proof}{(Combinatorial.)}
    We know that the number of solutions to $\sum_{i=1}^k x_i = n$ is
    $\binom{n+k-1}{k-1}$ and intuitively gives the number of ways we may
    distribute $n$ items among $k$ containers.

    Another way to look at this is to imagine an algorithm that counts these
    different distributions of items among the containers.

    A naive such procedure could operate recursively, by knowing two pieces of
    information at each stage: the number of containers in consideration and
    the number of items to distribute among them.
    We reach a base case when there is a single container into which any number
    of items must be distributed, as there is a unique way in which to perform
    this distribution.
    The algorithm would first assign $0$ items to the first container,
    and then recursively determine how to distribute all $n$ remaining items
    among the remaining $k-1$ containers;
    then, the algorithm could assign $1$ item to the first container, and
    inductively compute how to distribute the $n-1$ items among the remaining
    $k-1$ containers; and so on.
    Once these counts have all been determined, the procedure adds all the
    counts and produces the final sum.

    This procedure establishes a bijective proof that
    %
    \begin{equation*}
        \binom{n + k - 1}{k - 1}
        = \sum_{i=0}^n \binom{(n - i) + (k - 1) - 1}{(k - 1) - 1}
        = \sum_{i=0}^n \binom{n + k - 2 - i}{k - 2}
    \end{equation*}

    Then, perform the substitution $m = k - 2$ and $n^\prime = n + m$ to
    obtain
    %
    \begin{equation*}
        \binom{n^\prime + 1}{m + 1}
        =
        \sum_{i=0}^n \binom{n^\prime - i}{m}
        = 
        \sum_{i=m}^{n^\prime} \binom{i}{m}
    \end{equation*}
    %
    as required.
\end{proof}

\question{Labelled trees}

\begin{prop}
    Let $f : \nset \to \nset$ and $T_f$ be a labelled tree on $n$ vertices
    constructed by the procedure seen in class.
    Suppose $T_f$ contains a vertex of degree at least $k$.
    Then $f$ takes on at most $n - k + 2$ different values.
\end{prop}

\begin{proof}
    First remark that if $k < 3$, the upper bound is simply $n$ which is a
    trivial bound. We assume that $k \geq 3$ for the remainder of the proof.

    The size of the image of such a function can be found by looking at the
    number of ``duplicates'' in the graph. We say that a point $y \in \nset$
    has $k$ duplicates under $f$ if $\abs{f\preimage{y}} = k + 1$.
    The number of duplicates in $f$ is the sum of the number of duplicates
    across all points in the image of $f$.

    Now consider $T_f$.
    The tree consists of two types of vertices.
    We have \emph{backbone} vertices, corresponding to those vertices belonging
    to a cycle in the graph of $f$; and \emph{appendage} vertices,
    corresponding to those vertices not belonging to cycles.

    The backbone of the tree corresponds to the ``bijective part'' of $f$.
    Formally, if we restrict $f$ to its backbone, then we have a bijection.

    Backbone vertices are tricky because the ones on the ``ends'' of the tree
    have only one edge due to the cycle, whereas the ``inner'' backbone
    vertices have two edges due to edges from cycles in the graph of $f$.

    Suppose an end backbone vertex labelled $y$ has degree at least $k \geq 3$.
    Then, there are at least $k - 1 \geq 2$ appendage vertices adjacent to it.
    By the construction, appendage vertices come directly from the graph of
    $f$.
    This means that there are at least $k$ values in the domain of $f$
    --
    at least $k-1$ due to the appendage vertices plus exactly one because the
    backbone edge is in a cycle
    --
    that are mapped to $y$ under $f$.
    Consequently, these $k-1$ appendage vertices are not going elsewhere, so
    there are $k-1$ elements in the codomain of $f$ that are unmapped.
    Hence, the size of the image of $f$ is at most $n - k + 1$.

    The same argument applies for inner backbone vertices, but we have to
    subtract $2$ instead of one, since two edges come from the cycle.

    Finally, appendage vertices have exactly one edge that corresponds with an
    outgoing edge in the graph of $f$. Hence they are treated the same was as
    end backbone vertices, and result in a bound of $n - k + 1$.

    The most restrictive of these bounds is the one resulting from inner
    backbone edges, and this bound is precisely the one we are seeking.
\end{proof}

\end{document}
